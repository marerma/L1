// Реализовать аналог библиотеки Math (можно назвать MathX) с базовым набором функций, используя замыкания:
// вычисление N-го числа в ряду Фибоначчи 
// вычисление всех чисел в ряду Фибоначчи до числа N
// вычисление N-го простого числа
// вычисление всех простых чисел до числа N

// функция мемоизации функции: если с функция вызывается с аргументом, для которого уже высчитывался результат, то результат возьмется из кеша
function memo(fn) {
  const memoMap = new Map();

  return (arg) => {
    if (!memoMap.has(arg)) {
      const result = fn(arg);
      memoMap.set(arg, result);
      return result;
    } else {
      return memoMap.get(arg);
    }
  }
};

const MathX  = {
  //общая функция для определения простого числа для переиспользования в других методах
  isPrime(num) {
    // если ввели единицу, то возвращаем ложь, иначе идем циклом от 2 до введенного числа и проверяем, есть ли еще делители кроме единицы
    // если есть - то число не простое и возвращаем лоь
    if (num === 1) {
      return false;
    } else {
        for (let i = 2; i < num; i++) {
          if (num % i === 0) return false;
        }
        return true;
    }
  },
// получение n-ного числа Фибоначчи с использованием перестановки значений и переопределения переменных
  getNthFibonacciNum: memo(function (n) {
    let a = 1;
    let b = 1;
    
    // первое и второе число Фибиначчи это 1, если индекс 1 или 2, то выводим ответ сразу
    if (n === 1 || n === 2) {
      return a;
    }
    // идем циклом начиная с 3 и до введенного числа, по окончании цикла b будет искомым ответом
    for (let i = 3; i <= n; i++) {
      let c = a + b;
      a = b;
      b = c;
    }
    return b;
  }),

  // заполняем массив числами Фибоначчи до тех пор, пока последнее не будет равно введенному числу.
  // в данном решении введенное число включается в границу и итоговый список, также включается и нулевой элемент последовательности
  getAllFibNums: memo(function (n) {
    // если введено отрицательное число или не число, возвращается пустая последовтельность 
    if (n < 0 || isNaN(n)) {
      return [];
    }
    // если введен 0, то возвращаем последовательность Фибоначчи с нулевым числом в ряду 0
    if (n === 0) {
      return [0]
    }
    // иначе идем циклом начиная с числа 1 (первое число в последовательности, следовательно iteration начинаем с 1, индекса единицы в последовательности) и добавляем в массив числа фибоначчи,
    // используя уже готовый метод получения n-ного числа Фибоначчи
    const allFibNums = [0];
    let fibNum = 1;
    let interation = 1;
   
    while (fibNum <= n) {
      allFibNums.push(fibNum);
      interation++;
      fibNum = MathX.getNthFibonacciNum(interation);
    }
    return allFibNums;
  }),

  
  // если введен ноль, отрицательное число или не число, выбрасывается ошибка
  getPrimeNthNum: memo(function (n) {
    if (n <= 0 || isNaN(n)) {
      throw new Error('Проверьте индекс: он должен быть положительным числом больше 0');
    }
    // итерируемся по числам, начиная с первого простого числа 2. Пока кол-во итераций меньше введенного индекса, обновляем простое число
    // как только выходим из цикла, это значит, что мы достигли нужного порядкового номера простого числа и возвращаем число
    let count = 0;
    let number = 2;
    let prime;
  
    while (count < n) {
      if (MathX.isPrime(number)) {
        prime = number;
        count++;
      }
      number++;
    }
  
    return prime;
  }),

    // заполняем массив простыми числами, пока не дойдем до нужного числа. 
    //  в данном решении введенное число включается в границу поиска и попадает в итоговый список
  getAllPrimeNums: memo(function (n) {
    const primeNums = [];
    let number = 2;
    while (number <= n) {
      if (MathX.isPrime(number)) {
        primeNums.push(number);
      }
      number++;
    }
    return primeNums;
  }),
}